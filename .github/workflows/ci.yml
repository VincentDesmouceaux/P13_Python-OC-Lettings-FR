# CI/CD Pipeline pour application Django - Linting, Tests, Build et D√©ploiement
#
# Objectifs :
# 1. Ex√©cuter les tests et le linting sur chaque push/pull request
# 2. Construire et pousser une image Docker multi-architectures (sur main/master)
# 3. D√©ployer automatiquement sur Northflank apr√®s un build r√©ussi
#
# D√©clencheurs :
# - Sur tout push vers n'importe quelle branche
# - Sur toute pull request
# - D√©clenchement manuel via l'interface GitHub
#
# Variables d'environnement :
# - PY_VER : Version Python (d√©finie dans les secrets GitHub)
# - DJANGO_SECRET_KEY : Cl√© secr√®te pour les tests
# - DOCKER_REPO/IMAGE_TAG : Configuration du registre Docker
# - SENTRY_* : Configuration pour les releases Sentry
# - NF_* : Configuration pour le d√©ploiement Northflank
#
# Workflow en 3 √©tapes :
# 1. Test : Linting (flake8) + Tests unitaires (pytest) avec couverture de code
# 2. Build : Construction et publication de l'image Docker (multi-arch)
# 3. Deploy : D√©clenchement du d√©ploiement sur Northflank
#
# Artefacts g√©n√©r√©s :
# - Rapport de couverture de code (HTML+XML)
# - Rapport flake8
# - Digest de l'image Docker

name: CI ‚Äì lint, tests, build & deploy

# D√©clencheurs du workflow
on:
  push:
    branches: ['**']        # Toutes les branches
  pull_request: {}          # Toutes les PRs
  workflow_dispatch: {}     # Permet un d√©clenchement manuel

##############################################################################
# Configuration globale
##############################################################################
env:
  PY_VER: ${{ secrets.PY_VER }}  # Version Python (ex: '3.12')

jobs:
  ############################################################################
  # √âtape 1 : Tests et qualit√© de code
  ############################################################################
  test:
    name: Run Tests & Linting
    runs-on: ubuntu-latest  # Ex√©cution sur le dernier Ubuntu
    
    # Variables d'environnement sp√©cifiques au job
    env:
      PY_VER: ${{ secrets.PY_VER }}  # R√©cup√®re la version Python
      DJANGO_SECRET_KEY: ci-dummy-secret  # Cl√© secr√®te pour les tests Django
    
    steps:
      # √âtape 1.1 : Checkout du code
      - uses: actions/checkout@v4
      
      # √âtape 1.2 : Configuration de Python
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PY_VER }}  # Version sp√©cifi√©e
      
      # √âtape 1.3 : Cache des d√©pendances pour acc√©l√©rer les builds
      - uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
      
      # √âtape 1.4 : Installation des d√©pendances et ex√©cution des tests
      - name: Install deps, lint & tests
        run: |
          # Mise √† jour de pip et installation des d√©pendances
          python -m pip install --upgrade pip
          pip install -r requirements.txt flake8 pytest-cov
          
          # Linting avec flake8 (rapport enregistr√© dans flake8-report.txt)
          flake8 . | tee flake8-report.txt
          
          # Tests unitaires avec couverture de code
          # - G√©n√®re des rapports XML (pour SonarQube) et HTML
          # - √âchoue si la couverture est <80%
          pytest --cov=. --cov-report=xml --cov-report=html --cov-fail-under=80
      
      # √âtape 1.5 : Archivage des r√©sultats des tests
      - name: Upload test artefacts
        uses: actions/upload-artifact@v4
        with:
          name: test-artifacts      # Nom du bundle d'artefacts
          path: |                   # Fichiers √† archiver
            coverage.xml            # Rapport de couverture (format XML)
            htmlcov                 # Rapport de couverture (format HTML)
            flake8-report.txt       # Rapport du linter
          retention-days: 14        # Conservation pendant 14 jours

  ############################################################################
  # √âtape 2 : Build et publication de l'image Docker
  ############################################################################
  docker:
    name: Build & Push Docker Image
    needs: test  # D√©pend de l'√©tape de tests
    
    # Conditions d'ex√©cution :
    # - Seulement si les tests passent
    # - Uniquement sur les branches main/master
    if: |
      needs.test.result == 'success' &&
      (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main')
    
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write  # Permission pour pousser sur Docker Hub
    
    # Variables sp√©cifiques au d√©ploiement Docker
    env:
      DOCKER_REPO: ${{ secrets.DOCKER_REPO }}  # Nom du repository Docker
      IMAGE_TAG:  ${{ secrets.IMAGE_TAG }}     # Tag de l'image (ex: 'latest')
    
    steps:
      # √âtape 2.1 : Checkout du code (avec historique complet)
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # R√©cup√®re tout l'historique Git
      
      # √âtape 2.2 : Configuration de l'environnement de build multi-arch
      - uses: docker/setup-qemu-action@v3     # Support multi-architectures
      - uses: docker/setup-buildx-action@v3   # Configuration de Buildx
      
      # √âtape 2.3 : Authentification sur Docker Hub
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      # √âtape 2.4 : Construction et publication de l'image
      - name: Build & push (amd64 + arm64)
        id: build  # Identifiant pour r√©cup√©rer les outputs
        uses: docker/build-push-action@v5
        with:
          context: .  # R√©pertoire de build
          platforms: linux/amd64,linux/arm64  # Support x64 et ARM
          push: true  # Publication automatique
          tags: |     # Tags appliqu√©s √† l'image
            ${{ env.DOCKER_REPO }}:${{ env.IMAGE_TAG }}  # Tag stable
            ${{ env.DOCKER_REPO }}:${{ github.sha }}     # Tag avec commit SHA
          build-args: |  # Arguments de build
            GIT_SHA=${{ github.sha }}  # Passe le SHA du commit
          cache-from: type=gha  # Utilisation du cache GitHub
          cache-to:   type=gha,mode=max
          provenance: false     # D√©sactiv√© pour compatibilit√© multi-arch
      
      # √âtape 2.5 : Archivage du digest de l'image
      - name: Export image digests
        run: |
          # Enregistre le digest de l'image pour r√©f√©rence future
          echo "${{ steps.build.outputs.digest }}" > image-digest.txt
      
      - name: Upload image digest
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-digest  # Nom de l'artefact
          path: image-digest.txt     # Fichier contenant le digest
          retention-days: 14
      
      # √âtape 2.6 : Cr√©ation d'une release Sentry
      - name: Notify Sentry release
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG:        ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT:    ${{ secrets.SENTRY_PROJECT }}
          SENTRY_URL:        ${{ secrets.SENTRY_URL }}
        with:
          environment: production  # Environnement de la release
          version:      ${{ github.sha }}  # Version = SHA du commit
          projects:     "${{ secrets.SENTRY_PROJECT }}"  # Projet(s) concern√©(s)
          set_commits:  auto      # Association automatique des commits
          ignore_missing: true    # Ignore les erreurs si projet non trouv√©

  ############################################################################
  # √âtape 3 : D√©ploiement sur Northflank
  ############################################################################
  deploy:
    name: Deploy to Northflank
    needs: docker  # D√©pend de l'√©tape Docker
    
    # Ex√©cution seulement si le build Docker r√©ussit
    if: needs.docker.result == 'success'
    
    runs-on: ubuntu-latest
    env:
      NF_TOKEN:      ${{ secrets.NORTHFLANK_TOKEN }}  # Token d'API Northflank
      NF_PROJECT_ID: ${{ secrets.NF_PROJECT_ID }}     # ID du projet
      NF_OBJECT_ID:  ${{ secrets.NF_OBJECT_ID }}      # ID du service
    
    steps:
      # √âtape 3.1 : D√©clenchement du build sur Northflank
      - name: Trigger Northflank build
        continue-on-error: true  # Continue m√™me en cas d'erreur
        run: |
          set -euo pipefail  # Mode strict pour la gestion d'erreurs
          
          # Construction de l'URL de l'API Northflank
          API="https://api.northflank.com/v1/projects/${NF_PROJECT_ID}/services/${NF_OBJECT_ID}/build"
          echo "üîó  POST $API"
          
          # Appel √† l'API Northflank
          http=$(curl -sS -o /tmp/resp.json -w '%{http_code}' \
            -X POST "$API" \
            -H "Authorization: Bearer ${NF_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{"reason":"GitHub Action auto-build"}')
          
          echo "‚Ü™Ô∏é HTTP ${http}"  # Affiche le code de r√©ponse
          cat /tmp/resp.json || true  # Affiche la r√©ponse (pour debugging)
          
          # V√©rification du code HTTP
          if [[ "$http" =~ ^2[0-9]{2}$ ]]; then
            echo "‚úÖ Build d√©clench√© ‚Äì suivez-le sur Northflank."
          else
            echo "‚ö†Ô∏è  Build NON d√©clench√© (HTTP $http) ‚Äì workflow poursuivi."
          fi
      
      # √âtape 3.2 : Notification finale
      - name: Final notice
        run: echo "üåê Si build OK ‚Üí https://p01--holiday-homes--c7br8w6v87r6.code.run"